import AccessControl "authorization/access-control";
import Map "mo:core/Map";
import Array "mo:core/Array";
import Iter "mo:core/Iter";
import Text "mo:core/Text";
import Nat "mo:core/Nat";
import Time "mo:core/Time";
import MixinStorage "blob-storage/Mixin";
import Storage "blob-storage/Storage";
import Principal "mo:core/Principal";
import Runtime "mo:core/Runtime";
import Int "mo:core/Int";
import Char "mo:core/Char";
import Order "mo:core/Order";

actor {
  // Storage for uploaded files/blobs
  include MixinStorage();

  // User types
  type UserRole = AccessControl.UserRole;

  type UserProfile = {
    username : Text;
    bio : Text;
    profilePicture : ?Storage.ExternalBlob;
    isGuest : Bool;
    principal : ?Principal;
  };

  module UserProfile {
    public func compare(profile1 : UserProfile, profile2 : UserProfile) : Order.Order {
      Text.compare(profile1.username, profile2.username);
    };
  };

  // Post types
  type Post = {
    id : Nat;
    author : Principal;
    contentType : ContentType;
    caption : Text;
    media : Storage.ExternalBlob;
    timestamp : Time.Time;
    isVideo : Bool;
    likeCount : Nat;
    commentCount : Nat;
    slug : Text;
  };

  type Comment = {
    id : Nat;
    author : Principal;
    postId : Nat;
    content : Text;
    timestamp : Time.Time;
  };

  type Message = {
    id : Nat;
    sender : Principal;
    receiver : Principal;
    content : Text;
    timestamp : Time.Time;
    read : Bool;
  };

  type SlugResult = {
    slug : Text;
    exists : Bool;
  };

  module SlugResult {
    public func compare(result1 : SlugResult, result2 : SlugResult) : Order.Order {
      Text.compare(result1.slug, result2.slug);
    };
  };

  type ContentType = {
    #image;
    #video;
    #shortVideo;
  };

  type MediaUploadRequest = {
    contentType : ContentType;
    caption : Text;
    media : Storage.ExternalBlob;
    isVideo : Bool;
  };

  // State
  let accessControlState = AccessControl.initState();

  let userProfiles = Map.empty<Principal, UserProfile>();
  let posts = Map.empty<Nat, Post>();
  let comments = Map.empty<Nat, Comment>();
  let messages = Map.empty<Nat, Message>();
  let likes = Map.empty<Text, Nat>(); // Key format: postId_user
  let duplicates = Map.empty<Text, Bool>();
  var nextPostId = 1;
  var nextCommentId = 1;
  var nextMessageId = 1;

  // Authentication & Authorization
  public shared ({ caller }) func initializeAccessControl() : async () {
    AccessControl.initialize(accessControlState, caller);
  };

  public query ({ caller }) func getCallerUserRole() : async AccessControl.UserRole {
    AccessControl.getUserRole(accessControlState, caller);
  };

  public shared ({ caller }) func assignCallerUserRole(user : Principal, role : AccessControl.UserRole) : async () {
    AccessControl.assignRole(accessControlState, caller, user, role);
  };

  public query ({ caller }) func isCallerAdmin() : async Bool {
    AccessControl.isAdmin(accessControlState, caller);
  };

  // User Profile Management
  public shared ({ caller }) func createOrUpdateProfile(username : Text, bio : Text) : async () {
    if (not AccessControl.hasPermission(accessControlState, caller, #user)) {
      Runtime.trap("Unauthorized: Only users can create or update profiles");
    };

    validateUsername(username);
    let isGuest = caller.isAnonymous();

    let profile : UserProfile = {
      username;
      bio;
      profilePicture = null;
      isGuest;
      principal = if (isGuest) { null } else { ?caller };
    };

    userProfiles.add(caller, profile);
  };

  func validateUsername(username : Text) {
    if (username.trimStart(#char ' ').isEmpty()) {
      Runtime.trap("Username cannot be empty");
    };

    if (username.toArray().size() > 20) {
      Runtime.trap("Username max length is 20 characters");
    };

    let lowercaseUsername = username.map(
      func(ch) {
        if (ch >= 'A' and ch <= 'Z') {
          Char.fromNat32((ch.toNat32() - 'A'.toNat32()) + ('a').toNat32());
        } else {
          ch;
        };
      }
    );

    validateReservedSlugs(lowercaseUsername);

    for (char in username.toArray().values()) {
      let isNumeric = char.isDigit();

      let isSpecial = switch (char) {
        case ('.' or '-' or '_') { true };
        case (_) { false };
      };

      if (not (isNumeric or isSpecial)) {
        Runtime.trap("Username can only contain letters, numbers, '.', '-', and '_'");
      };
    };
  };

  func validateReservedSlugs(username : Text) {
    let reservedSlugs = ["feed", "explore", "shorts", "upload", "profile"];
    for (reserved in reservedSlugs.values()) {
      if (username == reserved) {
        Runtime.trap("Username is reserved");
      };
    };
  };

  public query ({ caller }) func getCallerUserProfile() : async ?UserProfile {
    if (not AccessControl.hasPermission(accessControlState, caller, #user)) {
      Runtime.trap("Unauthorized: Only users can view profiles");
    };
    userProfiles.get(caller);
  };

  public shared ({ caller }) func saveCallerUserProfile(profile : UserProfile) : async () {
    if (not AccessControl.hasPermission(accessControlState, caller, #user)) {
      Runtime.trap("Unauthorized: Only users can save profiles");
    };
    userProfiles.add(caller, profile);
  };

  public query ({ caller }) func getUserProfile(user : Principal) : async ?UserProfile {
    if (caller != user and not AccessControl.isAdmin(accessControlState, caller)) {
      Runtime.trap("Unauthorized: Can only view your own profile");
    };
    userProfiles.get(user);
  };

  func emailFromSlug(slug : Text) : Text {
    "siddhi." # slug # "@siddhi.world";
  }; ();

  // Utility functions
  func generateUniqueSlug(proposedSlug : Text) : Text {
    var finalSlug = proposedSlug;
    var counter = 1;

    while (duplicates.containsKey(finalSlug)) {
      finalSlug := proposedSlug # counter.toText();
      counter += 1;
    };

    duplicates.add(finalSlug, true);
    finalSlug;
  };

  // Main functions
  public shared ({ caller }) func uploadMedia(request : MediaUploadRequest) : async Post {
    if (not AccessControl.hasPermission(accessControlState, caller, #user)) {
      Runtime.trap("Unauthorized: Only users can upload media");
    };

    let postId = nextPostId;
    nextPostId += 1;

    let newPost : Post = {
      id = postId;
      author = caller;
      contentType = request.contentType;
      caption = request.caption;
      media = request.media;
      timestamp = Time.now();
      isVideo = request.isVideo;
      likeCount = 0;
      commentCount = 0;
      slug = generateUniqueSlug("post-" # postId.toText());
    };

    posts.add(postId, newPost);
    newPost;
  };

  // Like and comment counts
  public query ({ caller }) func getPostInteractionCounts(postId : Nat) : async ?(Nat, Nat) {
    if (not AccessControl.hasPermission(accessControlState, caller, #user)) {
      Runtime.trap("Unauthorized: Only users can view post interactions");
    };

    switch (posts.get(postId)) {
      case (?post) {
        ?(post.likeCount, post.commentCount);
      };
      case null { null };
    };
  };

  // Trending algorithm
  public query ({ caller }) func getTrendingPosts() : async [Post] {
    if (not AccessControl.hasPermission(accessControlState, caller, #user)) {
      Runtime.trap("Unauthorized: Only users can view trending posts");
    };

    let allPosts = posts.values().toArray();
    allPosts.sort(
      func(a : Post, b : Post) : Order.Order {
        let scoreA = a.likeCount * 2 + a.commentCount;
        let scoreB = b.likeCount * 2 + b.commentCount;
        Nat.compare(scoreB, scoreA);
      }
    );
  };

  // Chat system
  public shared ({ caller }) func sendMessage(receiver : Principal, content : Text) : async Message {
    if (not AccessControl.hasPermission(accessControlState, caller, #user)) {
      Runtime.trap("Unauthorized: Only users can send messages");
    };

    let messageId = nextMessageId;
    nextMessageId += 1;

    let message : Message = {
      id = messageId;
      sender = caller;
      receiver;
      content;
      timestamp = Time.now();
      read = false;
    };

    messages.add(messageId, message);
    message;
  };

  public query ({ caller }) func getMessages(otherUser : Principal) : async [Message] {
    if (not AccessControl.hasPermission(accessControlState, caller, #user)) {
      Runtime.trap("Unauthorized: Only users can view messages");
    };

    messages.values().toArray().filter(
      func(msg : Message) : Bool {
        (msg.sender == caller and msg.receiver == otherUser) or
        (msg.sender == otherUser and msg.receiver == caller)
      }
    );
  };

  // Utility endpoint for slug existence check
  public query ({ caller }) func checkSlugExists(slug : Text) : async Bool {
    if (not AccessControl.hasPermission(accessControlState, caller, #user)) {
      Runtime.trap("Unauthorized: Only users can check slug existence");
    };
    duplicates.containsKey(slug);
  };

  // Post interaction functions
  public shared ({ caller }) func likePost(postId : Nat) : async () {
    if (not AccessControl.hasPermission(accessControlState, caller, #user)) {
      Runtime.trap("Unauthorized: Only users can like posts");
    };

    switch (posts.get(postId)) {
      case (?post) {
        let likeKey = postId.toText() # "_" # caller.toText();

        switch (likes.get(likeKey)) {
          case (?_) {
            // Unlike
            likes.remove(likeKey);
            let updatedPost = {
              post with likeCount = if (post.likeCount > 0) { post.likeCount - 1 } else { 0 };
            };
            posts.add(postId, updatedPost);
          };
          case null {
            // Like
            likes.add(likeKey, 1);
            let updatedPost = {
              post with likeCount = post.likeCount + 1;
            };
            posts.add(postId, updatedPost);
          };
        };
      };
      case null {
        Runtime.trap("Post does not exist");
      };
    };
  };

  public shared ({ caller }) func commentOnPost(postId : Nat, content : Text) : async Comment {
    if (not AccessControl.hasPermission(accessControlState, caller, #user)) {
      Runtime.trap("Unauthorized: Only users can comment on posts");
    };

    switch (posts.get(postId)) {
      case (?post) {
        let commentId = nextCommentId;
        nextCommentId += 1;

        let comment : Comment = {
          id = commentId;
          author = caller;
          postId;
          content;
          timestamp = Time.now();
        };

        comments.add(commentId, comment);

        let updatedPost = {
          post with commentCount = post.commentCount + 1;
        };
        posts.add(postId, updatedPost);

        comment;
      };
      case null {
        Runtime.trap("Post does not exist");
      };
    };
  };

  public query ({ caller }) func getPostComments(postId : Nat) : async [Comment] {
    if (not AccessControl.hasPermission(accessControlState, caller, #user)) {
      Runtime.trap("Unauthorized: Only users can view comments");
    };

    comments.values().toArray().filter(
      func(comment : Comment) : Bool {
        comment.postId == postId
      }
    );
  };

  public query ({ caller }) func getUserPosts(user : Principal) : async [Post] {
    if (not AccessControl.hasPermission(accessControlState, caller, #user)) {
      Runtime.trap("Unauthorized: Only users can view user posts");
    };

    posts.values().toArray().filter(
      func(post : Post) : Bool {
        post.author == user
      }
    );
  };

  public query ({ caller }) func getAllPosts() : async [Post] {
    if (not AccessControl.hasPermission(accessControlState, caller, #user)) {
      Runtime.trap("Unauthorized: Only users can view posts");
    };

    let allPosts = posts.values().toArray();
    allPosts.sort(
      func(a : Post, b : Post) : Order.Order {
        Int.compare(b.timestamp, a.timestamp);
      }
    );
  };

  public query ({ caller }) func getShortVideos() : async [Post] {
    if (not AccessControl.hasPermission(accessControlState, caller, #user)) {
      Runtime.trap("Unauthorized: Only users can view short videos");
    };

    let shortVideos = posts.values().toArray().filter(
      func(post : Post) : Bool {
        switch (post.contentType) {
          case (#shortVideo) { true };
          case (_) { false };
        };
      }
    );

    shortVideos.sort(
      func(a : Post, b : Post) : Order.Order {
        Int.compare(b.timestamp, a.timestamp);
      }
    );
  };

  public shared ({ caller }) func deletePost(postId : Nat) : async () {
    if (not AccessControl.hasPermission(accessControlState, caller, #user)) {
      Runtime.trap("Unauthorized: Only users can delete posts");
    };

    switch (posts.get(postId)) {
      case (?post) {
        if (post.author != caller and not AccessControl.isAdmin(accessControlState, caller)) {
          Runtime.trap("Unauthorized: Can only delete your own posts");
        };
        posts.remove(postId);
      };
      case null {
        Runtime.trap("Post does not exist");
      };
    };
  };
};
